
// C program to print all permutations with duplicates allowed
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

#define KNOTEN 4

void ReadDB(int ZahlenArray[][KNOTEN]){
	FILE *fp;
	char Temp;
	int i = 0;
	int j=0;
	int Zahl[100]={};
	int Zeile=0;
	fp = fopen("knoten.txt", "r");
	char Array[120][KNOTEN];
	int k=0;
	if(fp==NULL) {
		printf("Konnte Datei nicht öffnen!\n");
	}
	//Lese alle Zahlen in ein char array
	while((Temp=fgetc(fp))!=EOF){
		if(Temp==10||Temp==32){
			Zeile++;
			i=0;
		}else{
			Array[Zeile][i]=Temp;
			i++;
		}
	}

	//string to int
	for(i=0;i<Zeile;i++){
		Zahl[i]=atoi(Array[i]);
	}

	//ints in 4x4 matrix einfuegen
	for(i=0;i<KNOTEN;i++){
		for(j=0;j<KNOTEN;j++){
			ZahlenArray[i][j]=Zahl[k];
			k++;
		}
	}


}

/* Function to swap values at two pointers */
void Swap(char *x, char *y)
{
	char Temp;
	Temp = *x;
	*x = *y;
	*y = Temp;
}

/* Function to print permutations of string
   This function takes three parameters:
   1. String
   2. Starting index of the string
   3. Ending index of the string. */

void Permute(char *a, int l, int r,char Feld[][KNOTEN+1])
{
	int i,j,k;
	 int NextFreeFeld=0;
	if (l == r){


		//da int static x nicht erlaubt ist muss das halt so, schau welches Feld als nächstes frei ist
		for(k=0;k<400;k++){
			if(strlen(Feld[k])>1){
				NextFreeFeld++;

		}else{
			break;
		}
		}



		//kopiere die varianten in das feld
		for(j=0;j<strlen(a);j++){
			Feld[NextFreeFeld][j]=       *(a+j);
		}
		Feld[NextFreeFeld][strlen(a)]='\0';
		//printf("%s\n ",feld[x]);

		NextFreeFeld++;


	}else{
		for (i = l; i <= r; i++)
		{
			Swap((a+l), (a+i));
			Permute(a, l+1, r,Feld);
			Swap((a+l), (a+i)); //backtrack
		}
	}
}


/* Driver program to test above functions */











void Varianten(char Feld[][KNOTEN+1]){
	char* Ursp=NULL;
	int i;
	int g;
	int o;
	int n;
	int k,j=0;
	int Doppelt=0;
	int l=0;
	char BaumEbene1[KNOTEN];
	char * BaumEbene2=(char*)malloc(sizeof(char)*(KNOTEN-1));
	char BaumEbene3[KNOTEN];
	Ursp=(char*)malloc((KNOTEN+1)*sizeof(char));
	char Aeste[5000][6]={'\0'};
	//erstelle ursprung
	for(i=1;i<=KNOTEN;i++){
		*(Ursp+i-1)=i+48;
	}

	//array für alle mods
	//kopiere ursprung an erste stelle
	for(i=0;i<KNOTEN;i++){
		Aeste[l][i]=Ursp[i];
	}
	l++;



	//erste modulationsstufe

	for(k=0;k<strlen(Ursp);k++){
		for(i=0;i<strlen(Ursp)-1;i++){
			if (j==k)j++;
			BaumEbene1[i]=Ursp[j];
			j++;
		}
		j=0;


		//prüfe auf duplikate
		for(g=0;g<=l;g++){
			if(strcmp(Aeste[g],BaumEbene1)==0||strlen(BaumEbene1)<2){
				Doppelt=1;
				break;
			}}
		if(Doppelt==0){
			strcpy(Aeste[l],BaumEbene1);
			l++;
		}
		Doppelt=0;


		//zweite modulationsstufe


		for(n=0;n<strlen(Ursp)-1;n++){
			for(i=0;i<strlen(BaumEbene1)-1;i++){
				if (j==n)j++;
				BaumEbene2[i]=BaumEbene1[j];
				j++;
			}
			j=0;

			//prüfe auf duplikate
			for(g=0;g<=l;g++){
				if(strcmp(Aeste[g],BaumEbene2)==0||strlen(BaumEbene2)<2){
					Doppelt=1;
					break;
				}}
			if(Doppelt==0){
				strcpy(Aeste[l],BaumEbene2);
				l++;
			}
			Doppelt=0;



			//dritte modulationsstufe
			for(o=0;o<strlen(Ursp)-2;o++){
				for(i=0;i<strlen(BaumEbene1)-1;i++){
					if (j==o)j++;
					BaumEbene3[i]=BaumEbene2[j];
					j++;
				}
				j=0;

				//prüfe auf duplikate
				for(g=0;g<=l;g++){
					if(strcmp(Aeste[g],BaumEbene3)==0||strlen(BaumEbene3)<2){
						Doppelt=1;
						break;
					}}
				if(Doppelt==0){
					strcpy(Aeste[l],BaumEbene3);
					l++;
				}
				Doppelt=0;
			}
		}

	}

	//weitergabe der daten an die permutationsfunktion

	for(i=0;i<l;i++){
		Permute(Aeste[i],0,strlen(Aeste[i])-1,Feld);
	}







}
























/*die funktion nutzt die permutationen um in den eingelesenen Daten zu indizieren und
 * Distanz und fahrtzeit zu berechnen
 *
 *
 */
void CombineData(char Feld[][KNOTEN+1],int Entfernungen[500], int ZahlenArray[][KNOTEN]){
	int i=0,k;
	int Anz=0;
	int z=0,s=0;
	int Pos;
	int Dist;
	char Strecke[9]={'\0'};
	char Verbindung='-';
	int j;
	float Zeit;
	float Entfernung;
	float Geschwindigkeit;
	//fahrt
	int Fahrt=0;

	//berechne anzahl auszugebener daten
	while(strchr(Feld[i],'1')||strchr(Feld[i],'2')||strchr(Feld[i],'3')||strchr(Feld[i],'4')){
		Anz++;
		i++;

	}


	for(k=0;k<Anz;k++){
		Dist=0;
		j=0;
		Zeit=0;
		Entfernung=0;
		Geschwindigkeit=0;


		int FeldGroesse=strlen(Feld[Fahrt]);

		//verbindung
		for(i=0;i<FeldGroesse+FeldGroesse-1;i++){
			if(i%2==0){
				Strecke[i]=Feld[Fahrt][j];
				j++;
			}else{
				Strecke[i]=Verbindung;
			}

		}
		//string ende
		Strecke[FeldGroesse*2-1]='\0';

		//printf("distance\n");




		//distanz
		for(Pos=0;Pos<FeldGroesse-1;Pos++){
			s=Feld[Fahrt][Pos]-48;
			z=Feld[Fahrt][Pos+1]-48;
			s=abs(1-s);
			z=abs(KNOTEN-z);
			//printf("z=%i s=%i",z,s);
			//temp1=entfernung
			Entfernung=(float)ZahlenArray[z][s];
			//printf("strecke= %f ",temp1);
			Dist=Dist+ZahlenArray[z][s];
			//fahrtzeit
			s=Feld[Fahrt][Pos]-48;
			z=Feld[Fahrt][Pos+1]-48;
			s=abs(KNOTEN-s);
			z=abs(1-z);
			//printf("z=%i s=%i",z,s);

			//temp2= geschwindigkeit
			Geschwindigkeit=(float)ZahlenArray[s][z];
			//printf("geschwindigkeit= %f ",temp2);


			Zeit=Zeit+Entfernung*60/Geschwindigkeit;
		}
		Zeit=Zeit+(FeldGroesse-2)*10;


		//ausgabe
		//das .0 bewirkt dass gerundet wird
		printf("\n%s\t\t",Strecke);
		printf("%i\t",Dist);
		printf("\t%.0f",Zeit);





		Fahrt++;
	}



}








int main()
{







	int ZahlenArray[KNOTEN][KNOTEN];
	int Entfernungen[500];
	char Feld[500][KNOTEN+1]={'0'};




	//ausgabe aller möglichen kombinationen
	printf("Anzahl der möglichen Streckenkombinationen mit 4 Knoten = 60\nAnzahl der möglichen Streckenkombinationen mit 3 Knoten = 12\nAnzahl der möglichen Streckenkombinationen mit 2 Knoten = 2\n");




	Varianten(Feld);
	ReadDB(ZahlenArray);

	CombineData(Feld,Entfernungen,ZahlenArray);





	return 0;
}
